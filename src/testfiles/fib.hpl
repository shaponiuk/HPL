interface FibI {
  fun (Int () -> Int ()) getFib;
};

struct FibStruct: FibI {
  private fun (Int () -> Int ()) pGetFib (0) = 0;
  private fun (Int () -> Int ()) pGetFib (1) = 1;
  private fun (Int () -> Int ()) pGetFib (x) = let 
    (Int () -> Int ()) :: f = { y ->
      pGetFib (y () - 1) + pGetFib (y () - 2)
    }; 
  in f (x ());

  fun (Int () -> Int ()) getFib (x) = pGetFib (x ());
};


struct Main {
  sus fun ((Semaphore (), IO ()) -> Maybe (String ())) susGetLine (sem, io) =
    force let
      () :: a = print ( "here" );
      () :: b = sem.V ();
    in io.getline ();

  fun ((List (String ()), IO ()) -> Int ()) main (argv, io) = force let 
    ref Sem () sem = Sem ();
    Maybe (String ()) :: x = susGetLine (sem (), io ());
  in let
    FibStruct () :: fib = FibStruct ();
  in force let
    Sem () :: e = sem.P();
    () :: y = print (fib.getFib (30));
  in 0;
};

//Program wejdzie do main, stworzy semafor, przekaże go do funkcji fun, która uruchomi się dopiero, jak main wykona sem.P ().
//Wtedy pierwsze wyświetli się "here" i semafor zostanie odblokowany.
//Ta sama funkcja na końcu pobierze linię z stdin.
//Po tym kontekst wróci do main, gdzie zostanie wyświetlona 30-ta liczba Fibbonaciego, (dopiero teraz stworzy się fib, leniwość).
//na końcu zwrócimy 0 jako wynik programu.
