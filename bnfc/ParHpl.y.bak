-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParHpl where
import qualified AbsHpl
import LexHpl
}

%name pProgram Program
%name pFunctionOrRefOrType FunctionOrRefOrType
%name pListFunctionOrRefOrType ListFunctionOrRefOrType
%name pFunctionDef FunctionDef
%name pFunctionArg FunctionArg
%name pListFunctionArg ListFunctionArg
%name pListFunctionDef ListFunctionDef
%name pValueStatement ValueStatement
%name pListValueStatement ListValueStatement
%name pRefDef RefDef
%name pType Type
%name pListType ListType
%name pAlgType AlgType
%name pTypeArg TypeArg
%name pListTypeArg ListTypeArg
%name pAlgTypeVal AlgTypeVal
%name pListAlgTypeVal ListAlgTypeVal
%name pPatternMatch PatternMatch
%name pListPatternMatch ListPatternMatch
%name pAssignment Assignment
%name pListAssignment ListAssignment
%name pFunApplication FunApplication
%name pFunctionArgAppl FunctionArgAppl
%name pListFunctionArgAppl ListFunctionArgAppl
%name pListValueStatementr ListValueStatementr
%name pTupleValueStatementr TupleValueStatementr
%name pValueStatementExpr ValueStatementExpr
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '->' { PT _ (TS _ 9) }
  '.' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  '::' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  '[' { PT _ (TS _ 20) }
  ']' { PT _ (TS _ 21) }
  'data' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'force' { PT _ (TS _ 24) }
  'fun' { PT _ (TS _ 25) }
  'if' { PT _ (TS _ 26) }
  'in' { PT _ (TS _ 27) }
  'let' { PT _ (TS _ 28) }
  'ref' { PT _ (TS _ 29) }
  'sus' { PT _ (TS _ 30) }
  'then' { PT _ (TS _ 31) }
  '{' { PT _ (TS _ 32) }
  '|' { PT _ (TS _ 33) }
  '}' { PT _ (TS _ 34) }
  L_Ident  { PT _ (TV $$) }
  L_integ  { PT _ (TI $$) }
  L_quoted { PT _ (TL $$) }

%%

Ident :: { AbsHpl.Ident}
Ident  : L_Ident { AbsHpl.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read ($1)) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Program :: { (AbsHpl.Program ()) }
Program : ListFunctionOrRefOrType { AbsHpl.ProgramB () $1 }

FunctionOrRefOrType :: { (AbsHpl.FunctionOrRefOrType ()) }
FunctionOrRefOrType : FunctionDef { AbsHpl.FunctionOrRefOrTypeF () $1 }
                    | AlgType { AbsHpl.FunctionOrRefOrTypeT () $1 }
                    | RefDef { AbsHpl.FunctionOrRefOrTypeR () $1 }

ListFunctionOrRefOrType :: { [AbsHpl.FunctionOrRefOrType ()] }
ListFunctionOrRefOrType : {- empty -} { [] }
                        | FunctionOrRefOrType ListFunctionOrRefOrType { (:) $1 $2 }

FunctionDef :: { (AbsHpl.FunctionDef ()) }
FunctionDef : 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' { AbsHpl.FunctionDefB () $2 $3 $5 $8 }
            | 'sus' 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' { AbsHpl.SusFunctionDef () $3 $4 $6 $9 }

FunctionArg :: { (AbsHpl.FunctionArg ()) }
FunctionArg : PatternMatch { AbsHpl.FunctionArgB () $1 }

ListFunctionArg :: { [AbsHpl.FunctionArg ()] }
ListFunctionArg : {- empty -} { [] }
                | FunctionArg { (:[]) $1 }
                | FunctionArg ',' ListFunctionArg { (:) $1 $3 }

ListFunctionDef :: { [AbsHpl.FunctionDef ()] }
ListFunctionDef : {- empty -} { [] }
                | FunctionDef ListFunctionDef { (:) $1 $2 }

ValueStatement :: { (AbsHpl.ValueStatement ()) }
ValueStatement : 'let' ListAssignment 'in' ValueStatement { AbsHpl.ValueStatementB () $2 $4 }
               | 'force' 'let' ListAssignment 'in' ValueStatement { AbsHpl.ForceValueStatement () $3 $5 }
               | 'if' ValueStatement 'then' ValueStatement 'else' ValueStatement { AbsHpl.IfValueStatement () $2 $4 $6 }
               | ListValueStatementr { AbsHpl.LValueStatement () $1 }
               | TupleValueStatementr { AbsHpl.TValueStatement () $1 }
               | FunApplication { AbsHpl.AValueStatement () $1 }
               | Integer { AbsHpl.IValueStatement () $1 }
               | String { AbsHpl.LitStrValueStatement () $1 }
               | '{' Ident '->' ValueStatement '}' { AbsHpl.FValueStatement () $2 $4 }
               | ValueStatement ValueStatementExpr { AbsHpl.Expr () $1 $2 }

ListValueStatement :: { [AbsHpl.ValueStatement ()] }
ListValueStatement : {- empty -} { [] }
                   | ValueStatement { (:[]) $1 }
                   | ValueStatement ',' ListValueStatement { (:) $1 $3 }

RefDef :: { (AbsHpl.RefDef ()) }
RefDef : 'ref' Type Ident '=' ValueStatement ';' { AbsHpl.RefDefB () $2 $3 $5 }

Type :: { (AbsHpl.Type ()) }
Type : Ident '(' ListType ')' { AbsHpl.TypeB () $1 $3 }
     | '(' Type '->' Type ')' { AbsHpl.FunType () $2 $4 }
     | '(' ListType ')' { AbsHpl.TType () $2 }

ListType :: { [AbsHpl.Type ()] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type ',' ListType { (:) $1 $3 }

AlgType :: { (AbsHpl.AlgType ()) }
AlgType : 'data' Ident '(' ListTypeArg ')' '=' ListAlgTypeVal ';' { AbsHpl.AlgTypeB () $2 $4 $7 }

TypeArg :: { (AbsHpl.TypeArg ()) }
TypeArg : Ident { AbsHpl.TypeArgB () $1 }

ListTypeArg :: { [AbsHpl.TypeArg ()] }
ListTypeArg : {- empty -} { [] }
            | TypeArg { (:[]) $1 }
            | TypeArg ',' ListTypeArg { (:) $1 $3 }

AlgTypeVal :: { (AbsHpl.AlgTypeVal ()) }
AlgTypeVal : Ident '(' Type ')' { AbsHpl.AlgTypeValB () $1 $3 }

ListAlgTypeVal :: { [AbsHpl.AlgTypeVal ()] }
ListAlgTypeVal : {- empty -} { [] }
               | AlgTypeVal { (:[]) $1 }
               | AlgTypeVal '|' ListAlgTypeVal { (:) $1 $3 }

PatternMatch :: { (AbsHpl.PatternMatch ()) }
PatternMatch : Integer { AbsHpl.PatternMatchI () $1 }
             | Ident { AbsHpl.PatternMatchB () $1 }
             | '(' ListPatternMatch ')' { AbsHpl.TPatternMatch () $2 }
             | PatternMatch '(' ListPatternMatch ')' { AbsHpl.CPatternMatch () $1 $3 }

ListPatternMatch :: { [AbsHpl.PatternMatch ()] }
ListPatternMatch : {- empty -} { [] }
                 | PatternMatch { (:[]) $1 }
                 | PatternMatch ',' ListPatternMatch { (:) $1 $3 }

Assignment :: { (AbsHpl.Assignment ()) }
Assignment : Type '::' PatternMatch '=' ValueStatement ';' { AbsHpl.AssignmentB () $1 $3 $5 }
           | RefDef { AbsHpl.RefAssignment () $1 }

ListAssignment :: { [AbsHpl.Assignment ()] }
ListAssignment : {- empty -} { [] }
               | Assignment ListAssignment { (:) $1 $2 }

FunApplication :: { (AbsHpl.FunApplication ()) }
FunApplication : Ident '.' FunApplication { AbsHpl.SFunApplication () $1 $3 }
               | Ident '(' ListFunctionArgAppl ')' { AbsHpl.FunApplicationB () $1 $3 }

FunctionArgAppl :: { (AbsHpl.FunctionArgAppl ()) }
FunctionArgAppl : ValueStatement { AbsHpl.FunctionArgApplB () $1 }

ListFunctionArgAppl :: { [AbsHpl.FunctionArgAppl ()] }
ListFunctionArgAppl : {- empty -} { [] }
                    | FunctionArgAppl { (:[]) $1 }
                    | FunctionArgAppl ',' ListFunctionArgAppl { (:) $1 $3 }

ListValueStatementr :: { (AbsHpl.ListValueStatementr ()) }
ListValueStatementr : '[' ListValueStatement ']' { AbsHpl.ListValueStatementB () $2 }

TupleValueStatementr :: { (AbsHpl.TupleValueStatementr ()) }
TupleValueStatementr : '(' ListValueStatement ')' { AbsHpl.TupleValueStatementB () $2 }

ValueStatementExpr :: { (AbsHpl.ValueStatementExpr ()) }
ValueStatementExpr : '+' ValueStatement { AbsHpl.EAdd () $2 }
                   | '-' ValueStatement { AbsHpl.ESub () $2 }
                   | '%' ValueStatement { AbsHpl.EMod () $2 }
                   | '*' ValueStatement { AbsHpl.EMul () $2 }
                   | '/' ValueStatement { AbsHpl.EDiv () $2 }
                   | '<' ValueStatement { AbsHpl.EL () $2 }
                   | '<=' ValueStatement { AbsHpl.ELQ () $2 }
                   | '>' ValueStatement { AbsHpl.EG () $2 }
                   | '>=' ValueStatement { AbsHpl.EGQ () $2 }
                   | '==' ValueStatement { AbsHpl.EEQ () $2 }
                   | '!=' ValueStatement { AbsHpl.ENE () $2 }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

