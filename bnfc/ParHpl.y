-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParHpl where
import AbsHpl
import LexHpl
import ErrM

}

%name pProgram Program
%name pFunctionOrRefOrType FunctionOrRefOrType
%name pListFunctionOrRefOrType ListFunctionOrRefOrType
%name pFunctionDef FunctionDef
%name pFunctionArg FunctionArg
%name pListFunctionArg ListFunctionArg
%name pListFunctionDef ListFunctionDef
%name pValueStatement ValueStatement
%name pListValueStatement ListValueStatement
%name pRefDef RefDef
%name pType Type
%name pListType ListType
%name pAlgType AlgType
%name pTypeArg TypeArg
%name pListTypeArg ListTypeArg
%name pAlgTypeVal AlgTypeVal
%name pListAlgTypeVal ListAlgTypeVal
%name pPatternMatch PatternMatch
%name pListPatternMatch ListPatternMatch
%name pAssignment Assignment
%name pListAssignment ListAssignment
%name pFunApplication FunApplication
%name pFunctionArgAppl FunctionArgAppl
%name pListFunctionArgAppl ListFunctionArgAppl
%name pListValueStatementr ListValueStatementr
%name pTupleValueStatementr TupleValueStatementr
%name pValueStatementExpr ValueStatementExpr
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '->' { PT _ (TS _ 9) }
  '.' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  '::' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  '[' { PT _ (TS _ 20) }
  ']' { PT _ (TS _ 21) }
  'data' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'force' { PT _ (TS _ 24) }
  'fun' { PT _ (TS _ 25) }
  'if' { PT _ (TS _ 26) }
  'in' { PT _ (TS _ 27) }
  'let' { PT _ (TS _ 28) }
  'ref' { PT _ (TS _ 29) }
  'sus' { PT _ (TS _ 30) }
  'then' { PT _ (TS _ 31) }
  '{' { PT _ (TS _ 32) }
  '|' { PT _ (TS _ 33) }
  '}' { PT _ (TS _ 34) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }

Program :: { Program }
Program : ListFunctionOrRefOrType { AbsHpl.ProgramB (reverse $1) }
FunctionOrRefOrType :: { FunctionOrRefOrType }
FunctionOrRefOrType : FunctionDef { AbsHpl.FunctionOrRefOrTypeF $1 }
                    | AlgType { AbsHpl.FunctionOrRefOrTypeT $1 }
                    | RefDef { AbsHpl.FunctionOrRefOrTypeR $1 }
ListFunctionOrRefOrType :: { [FunctionOrRefOrType] }
ListFunctionOrRefOrType : {- empty -} { [] }
                        | ListFunctionOrRefOrType FunctionOrRefOrType { flip (:) $1 $2 }
FunctionDef :: { FunctionDef }
FunctionDef : 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' { AbsHpl.FunctionDefB $2 $3 $5 $8 }
            | 'sus' 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' { AbsHpl.SusFunctionDef $3 $4 $6 $9 }
FunctionArg :: { FunctionArg }
FunctionArg : PatternMatch { AbsHpl.FunctionArgB $1 }
ListFunctionArg :: { [FunctionArg] }
ListFunctionArg : {- empty -} { [] }
                | FunctionArg { (:[]) $1 }
                | FunctionArg ',' ListFunctionArg { (:) $1 $3 }
ListFunctionDef :: { [FunctionDef] }
ListFunctionDef : {- empty -} { [] }
                | ListFunctionDef FunctionDef { flip (:) $1 $2 }
ValueStatement :: { ValueStatement }
ValueStatement : 'let' ListAssignment 'in' ValueStatement { AbsHpl.ValueStatementB (reverse $2) $4 }
               | 'force' 'let' ListAssignment 'in' ValueStatement { AbsHpl.ForceValueStatement (reverse $3) $5 }
               | 'if' ValueStatement 'then' ValueStatement 'else' ValueStatement { AbsHpl.IfValueStatement $2 $4 $6 }
               | ListValueStatementr { AbsHpl.LValueStatement $1 }
               | TupleValueStatementr { AbsHpl.TValueStatement $1 }
               | FunApplication { AbsHpl.AValueStatement $1 }
               | Integer { AbsHpl.IValueStatement $1 }
               | String { AbsHpl.LitStrValueStatement $1 }
               | '{' Ident '->' ValueStatement '}' { AbsHpl.FValueStatement $2 $4 }
               | ValueStatement ValueStatementExpr { AbsHpl.Expr $1 $2 }
ListValueStatement :: { [ValueStatement] }
ListValueStatement : {- empty -} { [] }
                   | ValueStatement { (:[]) $1 }
                   | ValueStatement ',' ListValueStatement { (:) $1 $3 }
RefDef :: { RefDef }
RefDef : 'ref' Type Ident '=' ValueStatement ';' { AbsHpl.RefDefB $2 $3 $5 }
Type :: { Type }
Type : Ident '(' ListType ')' { AbsHpl.TypeB $1 $3 }
     | '(' Type '->' Type ')' { AbsHpl.FunType $2 $4 }
     | '(' ListType ')' { AbsHpl.TType $2 }
ListType :: { [Type] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type ',' ListType { (:) $1 $3 }
AlgType :: { AlgType }
AlgType : 'data' Ident '(' ListTypeArg ')' '=' ListAlgTypeVal ';' { AbsHpl.AlgTypeB $2 $4 $7 }
TypeArg :: { TypeArg }
TypeArg : Ident { AbsHpl.TypeArgB $1 }
ListTypeArg :: { [TypeArg] }
ListTypeArg : {- empty -} { [] }
            | TypeArg { (:[]) $1 }
            | TypeArg ',' ListTypeArg { (:) $1 $3 }
AlgTypeVal :: { AlgTypeVal }
AlgTypeVal : Ident '(' Type ')' { AbsHpl.AlgTypeValB $1 $3 }
ListAlgTypeVal :: { [AlgTypeVal] }
ListAlgTypeVal : {- empty -} { [] }
               | AlgTypeVal { (:[]) $1 }
               | AlgTypeVal '|' ListAlgTypeVal { (:) $1 $3 }
PatternMatch :: { PatternMatch }
PatternMatch : Integer { AbsHpl.PatternMatchI $1 }
             | Ident { AbsHpl.PatternMatchB $1 }
             | '(' ListPatternMatch ')' { AbsHpl.TPatternMatch $2 }
             | PatternMatch '(' ListPatternMatch ')' { AbsHpl.CPatternMatch $1 $3 }
ListPatternMatch :: { [PatternMatch] }
ListPatternMatch : {- empty -} { [] }
                 | PatternMatch { (:[]) $1 }
                 | PatternMatch ',' ListPatternMatch { (:) $1 $3 }
Assignment :: { Assignment }
Assignment : Type '::' PatternMatch '=' ValueStatement ';' { AbsHpl.AssignmentB $1 $3 $5 }
           | RefDef { AbsHpl.RefAssignment $1 }
ListAssignment :: { [Assignment] }
ListAssignment : {- empty -} { [] }
               | ListAssignment Assignment { flip (:) $1 $2 }
FunApplication :: { FunApplication }
FunApplication : Ident '.' FunApplication { AbsHpl.SFunApplication $1 $3 }
               | Ident '(' ListFunctionArgAppl ')' { AbsHpl.FunApplicationB $1 $3 }
FunctionArgAppl :: { FunctionArgAppl }
FunctionArgAppl : ValueStatement { AbsHpl.FunctionArgApplB $1 }
ListFunctionArgAppl :: { [FunctionArgAppl] }
ListFunctionArgAppl : {- empty -} { [] }
                    | FunctionArgAppl { (:[]) $1 }
                    | FunctionArgAppl ',' ListFunctionArgAppl { (:) $1 $3 }
ListValueStatementr :: { ListValueStatementr }
ListValueStatementr : '[' ListValueStatement ']' { AbsHpl.ListValueStatementB $2 }
TupleValueStatementr :: { TupleValueStatementr }
TupleValueStatementr : '(' ListValueStatement ')' { AbsHpl.TupleValueStatementB $2 }
ValueStatementExpr :: { ValueStatementExpr }
ValueStatementExpr : '+' ValueStatement { AbsHpl.EAdd $2 }
                   | '-' ValueStatement { AbsHpl.ESub $2 }
                   | '%' ValueStatement { AbsHpl.EMod $2 }
                   | '*' ValueStatement { AbsHpl.EMul $2 }
                   | '/' ValueStatement { AbsHpl.EDiv $2 }
                   | '<' ValueStatement { AbsHpl.EL $2 }
                   | '<=' ValueStatement { AbsHpl.ELQ $2 }
                   | '>' ValueStatement { AbsHpl.EG $2 }
                   | '>=' ValueStatement { AbsHpl.EGQ $2 }
                   | '==' ValueStatement { AbsHpl.EEQ $2 }
                   | '!=' ValueStatement { AbsHpl.ENE $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

