-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParHpl where
import AbsHpl
import LexHpl
import ErrM

}

%name pProgram Program
%name pStructOrInterfaceOrType StructOrInterfaceOrType
%name pListStructOrInterfaceOrType ListStructOrInterfaceOrType
%name pStruct Struct
%name pStructBody StructBody
%name pStructField StructField
%name pListStructField ListStructField
%name pFunctionDef FunctionDef
%name pFunctionArg FunctionArg
%name pListFunctionArg ListFunctionArg
%name pValueStatement ValueStatement
%name pListValueStatement ListValueStatement
%name pRefDef RefDef
%name pType Type
%name pListType ListType
%name pAlgType AlgType
%name pTypeArg TypeArg
%name pListTypeArg ListTypeArg
%name pAlgTypeVal AlgTypeVal
%name pListAlgTypeVal ListAlgTypeVal
%name pPatternMatch PatternMatch
%name pListPatternMatch ListPatternMatch
%name pAssignment Assignment
%name pListAssignment ListAssignment
%name pFunApplication FunApplication
%name pFunctionArgAppl FunctionArgAppl
%name pListFunctionArgAppl ListFunctionArgAppl
%name pListValueStatementr ListValueStatementr
%name pTupleValueStatementr TupleValueStatementr
%name pValueStatementExpr ValueStatementExpr

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '!=' { PT _ (TS _ 1) }
 '%' { PT _ (TS _ 2) }
 '(' { PT _ (TS _ 3) }
 ')' { PT _ (TS _ 4) }
 '*' { PT _ (TS _ 5) }
 '+' { PT _ (TS _ 6) }
 ',' { PT _ (TS _ 7) }
 '-' { PT _ (TS _ 8) }
 '->' { PT _ (TS _ 9) }
 '.' { PT _ (TS _ 10) }
 '/' { PT _ (TS _ 11) }
 '::' { PT _ (TS _ 12) }
 ';' { PT _ (TS _ 13) }
 '<' { PT _ (TS _ 14) }
 '<=' { PT _ (TS _ 15) }
 '=' { PT _ (TS _ 16) }
 '==' { PT _ (TS _ 17) }
 '>' { PT _ (TS _ 18) }
 '>=' { PT _ (TS _ 19) }
 '[' { PT _ (TS _ 20) }
 ']' { PT _ (TS _ 21) }
 'data' { PT _ (TS _ 22) }
 'else' { PT _ (TS _ 23) }
 'force' { PT _ (TS _ 24) }
 'fun' { PT _ (TS _ 25) }
 'if' { PT _ (TS _ 26) }
 'in' { PT _ (TS _ 27) }
 'let' { PT _ (TS _ 28) }
 'private' { PT _ (TS _ 29) }
 'ref' { PT _ (TS _ 30) }
 'struct' { PT _ (TS _ 31) }
 'sus' { PT _ (TS _ 32) }
 'then' { PT _ (TS _ 33) }
 '{' { PT _ (TS _ 34) }
 '|' { PT _ (TS _ 35) }
 '}' { PT _ (TS _ 36) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }

Program :: { Program }
Program : ListStructOrInterfaceOrType { ProgramB (reverse $1) } 


StructOrInterfaceOrType :: { StructOrInterfaceOrType }
StructOrInterfaceOrType : Struct { StructOrInterfaceOrTypeS $1 } 
  | AlgType { StructOrInterfaceOrTypeT $1 }


ListStructOrInterfaceOrType :: { [StructOrInterfaceOrType] }
ListStructOrInterfaceOrType : {- empty -} { [] } 
  | ListStructOrInterfaceOrType StructOrInterfaceOrType { flip (:) $1 $2 }


Struct :: { Struct }
Struct : 'struct' Ident '{' StructBody '}' ';' { StructB $2 $4 } 


StructBody :: { StructBody }
StructBody : ListStructField { StructBodyB (reverse $1) } 


StructField :: { StructField }
StructField : 'private' FunctionDef { StructFieldFunPr $2 } 
  | FunctionDef { StructFieldFunPu $1 }
  | 'private' RefDef { StructFieldRefPr $2 }
  | RefDef { StructFieldRefPu $1 }


ListStructField :: { [StructField] }
ListStructField : {- empty -} { [] } 
  | ListStructField StructField { flip (:) $1 $2 }


FunctionDef :: { FunctionDef }
FunctionDef : 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' { FunctionDefB $2 $3 $5 $8 } 
  | 'sus' FunctionDef { SusFunctionDef $2 }


FunctionArg :: { FunctionArg }
FunctionArg : PatternMatch { FunctionArgB $1 } 


ListFunctionArg :: { [FunctionArg] }
ListFunctionArg : {- empty -} { [] } 
  | FunctionArg { (:[]) $1 }
  | FunctionArg ',' ListFunctionArg { (:) $1 $3 }


ValueStatement :: { ValueStatement }
ValueStatement : 'let' ListAssignment 'in' ValueStatement { ValueStatementB (reverse $2) $4 } 
  | 'force' 'let' ListAssignment 'in' ValueStatement { ForceValueStatement (reverse $3) $5 }
  | 'if' ValueStatement 'then' ValueStatement 'else' ValueStatement { IfValueStatement $2 $4 $6 }
  | ListValueStatementr { LValueStatement $1 }
  | TupleValueStatementr { TValueStatement $1 }
  | FunApplication { AValueStatement $1 }
  | Integer { IValueStatement $1 }
  | String { LitStrValueStatement $1 }
  | '{' Ident '->' ValueStatement '}' { FValueStatement $2 $4 }
  | ValueStatement ValueStatementExpr { Expr $1 $2 }


ListValueStatement :: { [ValueStatement] }
ListValueStatement : {- empty -} { [] } 
  | ValueStatement { (:[]) $1 }
  | ValueStatement ',' ListValueStatement { (:) $1 $3 }


RefDef :: { RefDef }
RefDef : 'ref' Type Ident '=' ValueStatement ';' { RefDefB $2 $3 $5 } 


Type :: { Type }
Type : Ident '(' ListType ')' { TypeB $1 $3 } 
  | '(' Type '->' Type ')' { FunType $2 $4 }
  | '(' ListType ')' { TType $2 }


ListType :: { [Type] }
ListType : {- empty -} { [] } 
  | Type { (:[]) $1 }
  | Type ',' ListType { (:) $1 $3 }


AlgType :: { AlgType }
AlgType : 'data' Ident '(' ListTypeArg ')' '=' ListAlgTypeVal ';' { AlgTypeB $2 $4 $7 } 


TypeArg :: { TypeArg }
TypeArg : Ident { TypeArgB $1 } 


ListTypeArg :: { [TypeArg] }
ListTypeArg : {- empty -} { [] } 
  | TypeArg { (:[]) $1 }
  | TypeArg ',' ListTypeArg { (:) $1 $3 }


AlgTypeVal :: { AlgTypeVal }
AlgTypeVal : Ident '(' Type ')' { AlgTypeValB $1 $3 } 


ListAlgTypeVal :: { [AlgTypeVal] }
ListAlgTypeVal : {- empty -} { [] } 
  | AlgTypeVal { (:[]) $1 }
  | AlgTypeVal '|' ListAlgTypeVal { (:) $1 $3 }


PatternMatch :: { PatternMatch }
PatternMatch : Integer { PatternMatchI $1 } 
  | Ident { PatternMatchB $1 }
  | '(' ListPatternMatch ')' { TPatternMatch $2 }
  | PatternMatch '(' ListPatternMatch ')' { CPatternMatch $1 $3 }


ListPatternMatch :: { [PatternMatch] }
ListPatternMatch : {- empty -} { [] } 
  | PatternMatch { (:[]) $1 }
  | PatternMatch ',' ListPatternMatch { (:) $1 $3 }


Assignment :: { Assignment }
Assignment : Type '::' PatternMatch '=' ValueStatement ';' { AssignmentB $1 $3 $5 } 
  | RefDef { RefAssignment $1 }


ListAssignment :: { [Assignment] }
ListAssignment : {- empty -} { [] } 
  | ListAssignment Assignment { flip (:) $1 $2 }


FunApplication :: { FunApplication }
FunApplication : Ident '.' FunApplication { SFunApplication $1 $3 } 
  | Ident '(' ListFunctionArgAppl ')' { FunApplicationB $1 $3 }


FunctionArgAppl :: { FunctionArgAppl }
FunctionArgAppl : ValueStatement { FunctionArgApplB $1 } 


ListFunctionArgAppl :: { [FunctionArgAppl] }
ListFunctionArgAppl : {- empty -} { [] } 
  | FunctionArgAppl { (:[]) $1 }
  | FunctionArgAppl ',' ListFunctionArgAppl { (:) $1 $3 }


ListValueStatementr :: { ListValueStatementr }
ListValueStatementr : '[' ListValueStatement ']' { ListValueStatementB $2 } 


TupleValueStatementr :: { TupleValueStatementr }
TupleValueStatementr : '(' ListValueStatement ')' { TupleValueStatementB $2 } 


ValueStatementExpr :: { ValueStatementExpr }
ValueStatementExpr : '+' ValueStatement { EAdd $2 } 
  | '-' ValueStatement { ESub $2 }
  | '%' ValueStatement { EMod $2 }
  | '*' ValueStatement { EMul $2 }
  | '/' ValueStatement { EDiv $2 }
  | '<' ValueStatement { EL $2 }
  | '<=' ValueStatement { ELQ $2 }
  | '>' ValueStatement { EG $2 }
  | '>=' ValueStatement { EGQ $2 }
  | '==' ValueStatement { EEQ $2 }
  | '!=' ValueStatement { ENE $2 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

