-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParHpl where
import AbsHpl
import LexHpl
import ErrM

}

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%name pProgram_internal Program
%name pFunctionOrRefOrType_internal FunctionOrRefOrType
%name pListFunctionOrRefOrType_internal ListFunctionOrRefOrType
%name pFunctionDef_internal FunctionDef
%name pFunctionArg_internal FunctionArg
%name pListFunctionArg_internal ListFunctionArg
%name pListFunctionDef_internal ListFunctionDef
%name pValueStatement_internal ValueStatement
%name pListValueStatement_internal ListValueStatement
%name pRefDef_internal RefDef
%name pType_internal Type
%name pListType_internal ListType
%name pAlgType_internal AlgType
%name pTypeArg_internal TypeArg
%name pListTypeArg_internal ListTypeArg
%name pAlgTypeVal_internal AlgTypeVal
%name pListAlgTypeVal_internal ListAlgTypeVal
%name pPatternMatch_internal PatternMatch
%name pListPatternMatch_internal ListPatternMatch
%name pAssignment_internal Assignment
%name pListAssignment_internal ListAssignment
%name pFunApplication_internal FunApplication
%name pFunctionArgAppl_internal FunctionArgAppl
%name pListFunctionArgAppl_internal ListFunctionArgAppl
%name pListValueStatementr_internal ListValueStatementr
%name pTupleValueStatementr_internal TupleValueStatementr
%name pValueStatementExpr_internal ValueStatementExpr
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '->' { PT _ (TS _ 9) }
  '.' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  '::' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  '[' { PT _ (TS _ 20) }
  ']' { PT _ (TS _ 21) }
  'data' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'force' { PT _ (TS _ 24) }
  'fun' { PT _ (TS _ 25) }
  'if' { PT _ (TS _ 26) }
  'in' { PT _ (TS _ 27) }
  'let' { PT _ (TS _ 28) }
  'ref' { PT _ (TS _ 29) }
  'sus' { PT _ (TS _ 30) }
  'then' { PT _ (TS _ 31) }
  '{' { PT _ (TS _ 32) }
  '|' { PT _ (TS _ 33) }
  '}' { PT _ (TS _ 34) }

  L_ident {PT _ (TV _)}
  L_integ {PT _ (TI _)}
  L_quoted {PT _ (TL _)}

%%

Ident :: {
  (Maybe (Int, Int), Ident)
}
: L_ident {
  (Just (tokenLineCol $1), Ident (prToken $1)) 
}

Integer :: {
  (Maybe (Int, Int), Integer)
}
: L_integ {
  (Just (tokenLineCol $1), read (prToken $1)) 
}

String :: {
  (Maybe (Int, Int), String)
}
: L_quoted {
  (Just (tokenLineCol $1), prToken $1)
}

Program :: {
  (Maybe (Int, Int), Program (Maybe (Int, Int)))
}
: ListFunctionOrRefOrType {
  (fst $1, AbsHpl.ProgramB (fst $1)(reverse (snd $1)))
}

FunctionOrRefOrType :: {
  (Maybe (Int, Int), FunctionOrRefOrType (Maybe (Int, Int)))
}
: FunctionDef {
  (fst $1, AbsHpl.FunctionOrRefOrTypeF (fst $1)(snd $1)) 
}
| AlgType {
  (fst $1, AbsHpl.FunctionOrRefOrTypeT (fst $1)(snd $1)) 
}
| RefDef {
  (fst $1, AbsHpl.FunctionOrRefOrTypeR (fst $1)(snd $1)) 
}

ListFunctionOrRefOrType :: {
  (Maybe (Int, Int), [FunctionOrRefOrType (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| ListFunctionOrRefOrType FunctionOrRefOrType {
  (fst $1, flip (:) (snd $1)(snd $2)) 
}

FunctionDef :: {
  (Maybe (Int, Int), FunctionDef (Maybe (Int, Int)))
}
: 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' {
  (Just (tokenLineCol $1), AbsHpl.FunctionDefB (Just (tokenLineCol $1)) (snd $2)(snd $3)(snd $5)(snd $8)) 
}
| 'sus' 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' {
  (Just (tokenLineCol $1), AbsHpl.SusFunctionDef (Just (tokenLineCol $1)) (snd $3)(snd $4)(snd $6)(snd $9)) 
}

FunctionArg :: {
  (Maybe (Int, Int), FunctionArg (Maybe (Int, Int)))
}
: PatternMatch {
  (fst $1, AbsHpl.FunctionArgB (fst $1)(snd $1)) 
}

ListFunctionArg :: {
  (Maybe (Int, Int), [FunctionArg (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| FunctionArg {
  (fst $1, (:[]) (snd $1)) 
}
| FunctionArg ',' ListFunctionArg {
  (fst $1, (:) (snd $1)(snd $3)) 
}

ListFunctionDef :: {
  (Maybe (Int, Int), [FunctionDef (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| ListFunctionDef FunctionDef {
  (fst $1, flip (:) (snd $1)(snd $2)) 
}

ValueStatement :: {
  (Maybe (Int, Int), ValueStatement (Maybe (Int, Int)))
}
: 'let' ListAssignment 'in' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.ValueStatementB (Just (tokenLineCol $1)) (reverse (snd $2)) (snd $4)) 
}
| 'force' 'let' ListAssignment 'in' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.ForceValueStatement (Just (tokenLineCol $1)) (reverse (snd $3)) (snd $5)) 
}
| 'if' ValueStatement 'then' ValueStatement 'else' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.IfValueStatement (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $6)) 
}
| ListValueStatementr {
  (fst $1, AbsHpl.LValueStatement (fst $1)(snd $1)) 
}
| TupleValueStatementr {
  (fst $1, AbsHpl.TValueStatement (fst $1)(snd $1)) 
}
| FunApplication {
  (fst $1, AbsHpl.AValueStatement (fst $1)(snd $1)) 
}
| Integer {
  (fst $1, AbsHpl.IValueStatement (fst $1)(snd $1)) 
}
| String {
  (fst $1, AbsHpl.LitStrValueStatement (fst $1)(snd $1)) 
}
| '{' Ident '->' ValueStatement '}' {
  (Just (tokenLineCol $1), AbsHpl.FValueStatement (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| ValueStatement ValueStatementExpr {
  (fst $1, AbsHpl.Expr (fst $1)(snd $1)(snd $2)) 
}

ListValueStatement :: {
  (Maybe (Int, Int), [ValueStatement (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| ValueStatement {
  (fst $1, (:[]) (snd $1)) 
}
| ValueStatement ',' ListValueStatement {
  (fst $1, (:) (snd $1)(snd $3)) 
}

RefDef :: {
  (Maybe (Int, Int), RefDef (Maybe (Int, Int)))
}
: 'ref' Type Ident '=' ValueStatement ';' {
  (Just (tokenLineCol $1), AbsHpl.RefDefB (Just (tokenLineCol $1)) (snd $2)(snd $3)(snd $5)) 
}

Type :: {
  (Maybe (Int, Int), Type (Maybe (Int, Int)))
}
: Ident '(' ListType ')' {
  (fst $1, AbsHpl.TypeB (fst $1)(snd $1)(snd $3)) 
}
| '(' Type '->' Type ')' {
  (Just (tokenLineCol $1), AbsHpl.FunType (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| '(' ListType ')' {
  (Just (tokenLineCol $1), AbsHpl.TType (Just (tokenLineCol $1)) (snd $2)) 
}

ListType :: {
  (Maybe (Int, Int), [Type (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Type {
  (fst $1, (:[]) (snd $1)) 
}
| Type ',' ListType {
  (fst $1, (:) (snd $1)(snd $3)) 
}

AlgType :: {
  (Maybe (Int, Int), AlgType (Maybe (Int, Int)))
}
: 'data' Ident '(' ListTypeArg ')' '=' ListAlgTypeVal ';' {
  (Just (tokenLineCol $1), AbsHpl.AlgTypeB (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $7)) 
}

TypeArg :: {
  (Maybe (Int, Int), TypeArg (Maybe (Int, Int)))
}
: Ident {
  (fst $1, AbsHpl.TypeArgB (fst $1)(snd $1)) 
}

ListTypeArg :: {
  (Maybe (Int, Int), [TypeArg (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| TypeArg {
  (fst $1, (:[]) (snd $1)) 
}
| TypeArg ',' ListTypeArg {
  (fst $1, (:) (snd $1)(snd $3)) 
}

AlgTypeVal :: {
  (Maybe (Int, Int), AlgTypeVal (Maybe (Int, Int)))
}
: Ident '(' Type ')' {
  (fst $1, AbsHpl.AlgTypeValB (fst $1)(snd $1)(snd $3)) 
}

ListAlgTypeVal :: {
  (Maybe (Int, Int), [AlgTypeVal (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| AlgTypeVal {
  (fst $1, (:[]) (snd $1)) 
}
| AlgTypeVal '|' ListAlgTypeVal {
  (fst $1, (:) (snd $1)(snd $3)) 
}

PatternMatch :: {
  (Maybe (Int, Int), PatternMatch (Maybe (Int, Int)))
}
: Integer {
  (fst $1, AbsHpl.PatternMatchI (fst $1)(snd $1)) 
}
| Ident {
  (fst $1, AbsHpl.PatternMatchB (fst $1)(snd $1)) 
}
| '(' ListPatternMatch ')' {
  (Just (tokenLineCol $1), AbsHpl.TPatternMatch (Just (tokenLineCol $1)) (snd $2)) 
}
| PatternMatch '(' ListPatternMatch ')' {
  (fst $1, AbsHpl.CPatternMatch (fst $1)(snd $1)(snd $3)) 
}

ListPatternMatch :: {
  (Maybe (Int, Int), [PatternMatch (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| PatternMatch {
  (fst $1, (:[]) (snd $1)) 
}
| PatternMatch ',' ListPatternMatch {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Assignment :: {
  (Maybe (Int, Int), Assignment (Maybe (Int, Int)))
}
: Type '::' PatternMatch '=' ValueStatement ';' {
  (fst $1, AbsHpl.AssignmentB (fst $1)(snd $1)(snd $3)(snd $5)) 
}
| RefDef {
  (fst $1, AbsHpl.RefAssignment (fst $1)(snd $1)) 
}

ListAssignment :: {
  (Maybe (Int, Int), [Assignment (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| ListAssignment Assignment {
  (fst $1, flip (:) (snd $1)(snd $2)) 
}

FunApplication :: {
  (Maybe (Int, Int), FunApplication (Maybe (Int, Int)))
}
: Ident '.' FunApplication {
  (fst $1, AbsHpl.SFunApplication (fst $1)(snd $1)(snd $3)) 
}
| Ident '(' ListFunctionArgAppl ')' {
  (fst $1, AbsHpl.FunApplicationB (fst $1)(snd $1)(snd $3)) 
}

FunctionArgAppl :: {
  (Maybe (Int, Int), FunctionArgAppl (Maybe (Int, Int)))
}
: ValueStatement {
  (fst $1, AbsHpl.FunctionArgApplB (fst $1)(snd $1)) 
}

ListFunctionArgAppl :: {
  (Maybe (Int, Int), [FunctionArgAppl (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| FunctionArgAppl {
  (fst $1, (:[]) (snd $1)) 
}
| FunctionArgAppl ',' ListFunctionArgAppl {
  (fst $1, (:) (snd $1)(snd $3)) 
}

ListValueStatementr :: {
  (Maybe (Int, Int), ListValueStatementr (Maybe (Int, Int)))
}
: '[' ListValueStatement ']' {
  (Just (tokenLineCol $1), AbsHpl.ListValueStatementB (Just (tokenLineCol $1)) (snd $2)) 
}

TupleValueStatementr :: {
  (Maybe (Int, Int), TupleValueStatementr (Maybe (Int, Int)))
}
: '(' ListValueStatement ')' {
  (Just (tokenLineCol $1), AbsHpl.TupleValueStatementB (Just (tokenLineCol $1)) (snd $2)) 
}

ValueStatementExpr :: {
  (Maybe (Int, Int), ValueStatementExpr (Maybe (Int, Int)))
}
: '+' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EAdd (Just (tokenLineCol $1)) (snd $2)) 
}
| '-' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.ESub (Just (tokenLineCol $1)) (snd $2)) 
}
| '%' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EMod (Just (tokenLineCol $1)) (snd $2)) 
}
| '*' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EMul (Just (tokenLineCol $1)) (snd $2)) 
}
| '/' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EDiv (Just (tokenLineCol $1)) (snd $2)) 
}
| '<' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EL (Just (tokenLineCol $1)) (snd $2)) 
}
| '<=' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.ELQ (Just (tokenLineCol $1)) (snd $2)) 
}
| '>' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EG (Just (tokenLineCol $1)) (snd $2)) 
}
| '>=' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EGQ (Just (tokenLineCol $1)) (snd $2)) 
}
| '==' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.EEQ (Just (tokenLineCol $1)) (snd $2)) 
}
| '!=' ValueStatement {
  (Just (tokenLineCol $1), AbsHpl.ENE (Just (tokenLineCol $1)) (snd $2)) 
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens

pProgram = (>>= return . snd) . pProgram_internal
pFunctionOrRefOrType = (>>= return . snd) . pFunctionOrRefOrType_internal
pListFunctionOrRefOrType = (>>= return . snd) . pListFunctionOrRefOrType_internal
pFunctionDef = (>>= return . snd) . pFunctionDef_internal
pFunctionArg = (>>= return . snd) . pFunctionArg_internal
pListFunctionArg = (>>= return . snd) . pListFunctionArg_internal
pListFunctionDef = (>>= return . snd) . pListFunctionDef_internal
pValueStatement = (>>= return . snd) . pValueStatement_internal
pListValueStatement = (>>= return . snd) . pListValueStatement_internal
pRefDef = (>>= return . snd) . pRefDef_internal
pType = (>>= return . snd) . pType_internal
pListType = (>>= return . snd) . pListType_internal
pAlgType = (>>= return . snd) . pAlgType_internal
pTypeArg = (>>= return . snd) . pTypeArg_internal
pListTypeArg = (>>= return . snd) . pListTypeArg_internal
pAlgTypeVal = (>>= return . snd) . pAlgTypeVal_internal
pListAlgTypeVal = (>>= return . snd) . pListAlgTypeVal_internal
pPatternMatch = (>>= return . snd) . pPatternMatch_internal
pListPatternMatch = (>>= return . snd) . pListPatternMatch_internal
pAssignment = (>>= return . snd) . pAssignment_internal
pListAssignment = (>>= return . snd) . pListAssignment_internal
pFunApplication = (>>= return . snd) . pFunApplication_internal
pFunctionArgAppl = (>>= return . snd) . pFunctionArgAppl_internal
pListFunctionArgAppl = (>>= return . snd) . pListFunctionArgAppl_internal
pListValueStatementr = (>>= return . snd) . pListValueStatementr_internal
pTupleValueStatementr = (>>= return . snd) . pTupleValueStatementr_internal
pValueStatementExpr = (>>= return . snd) . pValueStatementExpr_internal
}

