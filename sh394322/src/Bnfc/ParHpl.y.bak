-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParHpl where
import AbsHpl
import LexHpl
import ErrM

}

%name pProgram Program
%name pStructOrInterfaceOrType StructOrInterfaceOrType
%name pListStructOrInterfaceOrType ListStructOrInterfaceOrType
%name pStruct Struct
%name pStructBody StructBody
%name pStructField StructField
%name pListStructField ListStructField
%name pInterfaceId InterfaceId
%name pListInterfaceId ListInterfaceId
%name pInterface Interface
%name pInterfaceBody InterfaceBody
%name pFunOrRefDecl FunOrRefDecl
%name pListFunOrRefDecl ListFunOrRefDecl
%name pFunctionDef FunctionDef
%name pFunctionArg FunctionArg
%name pListFunctionArg ListFunctionArg
%name pValueStatement ValueStatement
%name pListValueStatement ListValueStatement
%name pRefDef RefDef
%name pType Type
%name pListType ListType
%name pAlgType AlgType
%name pTypeArg TypeArg
%name pListTypeArg ListTypeArg
%name pAlgTypeVal AlgTypeVal
%name pListAlgTypeVal ListAlgTypeVal
%name pPatternMatch PatternMatch
%name pListPatternMatch ListPatternMatch
%name pAssignment Assignment
%name pListAssignment ListAssignment
%name pFunApplication FunApplication
%name pFunctionArgAppl FunctionArgAppl
%name pListFunctionArgAppl ListFunctionArgAppl
%name pListValueStatementr ListValueStatementr
%name pTupleValueStatementr TupleValueStatementr
%name pValueStatementExpr ValueStatementExpr
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '->' { PT _ (TS _ 9) }
  '.' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ':' { PT _ (TS _ 12) }
  '::' { PT _ (TS _ 13) }
  ';' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '=' { PT _ (TS _ 17) }
  '==' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  ']' { PT _ (TS _ 22) }
  'data' { PT _ (TS _ 23) }
  'else' { PT _ (TS _ 24) }
  'force' { PT _ (TS _ 25) }
  'fun' { PT _ (TS _ 26) }
  'if' { PT _ (TS _ 27) }
  'in' { PT _ (TS _ 28) }
  'interface' { PT _ (TS _ 29) }
  'let' { PT _ (TS _ 30) }
  'private' { PT _ (TS _ 31) }
  'ref' { PT _ (TS _ 32) }
  'struct' { PT _ (TS _ 33) }
  'sus' { PT _ (TS _ 34) }
  'then' { PT _ (TS _ 35) }
  '{' { PT _ (TS _ 36) }
  '|' { PT _ (TS _ 37) }
  '}' { PT _ (TS _ 38) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }

Program :: { Program }
Program : ListStructOrInterfaceOrType { AbsHpl.ProgramB (reverse $1) }
StructOrInterfaceOrType :: { StructOrInterfaceOrType }
StructOrInterfaceOrType : Struct { AbsHpl.StructOrInterfaceOrTypeS $1 }
                        | Interface { AbsHpl.StructOrInterfaceOrTypeI $1 }
                        | AlgType { AbsHpl.StructOrInterfaceOrTypeT $1 }
ListStructOrInterfaceOrType :: { [StructOrInterfaceOrType] }
ListStructOrInterfaceOrType : {- empty -} { [] }
                            | ListStructOrInterfaceOrType StructOrInterfaceOrType { flip (:) $1 $2 }
Struct :: { Struct }
Struct : 'struct' Ident '{' StructBody '}' ';' { AbsHpl.StructB $2 $4 }
       | 'struct' Ident ':' ListInterfaceId '{' StructBody '}' ';' { AbsHpl.StructI $2 $4 $6 }
StructBody :: { StructBody }
StructBody : ListStructField { AbsHpl.StructBodyB (reverse $1) }
StructField :: { StructField }
StructField : 'private' FunctionDef { AbsHpl.StructFieldFunPr $2 }
            | FunctionDef { AbsHpl.StructFieldFunPu $1 }
            | 'private' RefDef { AbsHpl.StructFieldRefPr $2 }
            | RefDef { AbsHpl.StructFieldRefPu $1 }
ListStructField :: { [StructField] }
ListStructField : {- empty -} { [] }
                | ListStructField StructField { flip (:) $1 $2 }
InterfaceId :: { InterfaceId }
InterfaceId : Ident { AbsHpl.InterfaceIdB $1 }
ListInterfaceId :: { [InterfaceId] }
ListInterfaceId : InterfaceId { (:[]) $1 }
                | InterfaceId ',' ListInterfaceId { (:) $1 $3 }
Interface :: { Interface }
Interface : 'interface' InterfaceId '{' InterfaceBody '}' ';' { AbsHpl.InterfaceB $2 $4 }
          | 'interface' InterfaceId ':' ListInterfaceId '{' InterfaceBody '}' ';' { AbsHpl.InterfaceBInh $2 $4 $6 }
InterfaceBody :: { InterfaceBody }
InterfaceBody : ListFunOrRefDecl { AbsHpl.InterfaceBodyB (reverse $1) }
FunOrRefDecl :: { FunOrRefDecl }
FunOrRefDecl : 'fun' Type Ident ';' { AbsHpl.FunOrRefDeclF $2 $3 }
             | 'sus' 'fun' Type Ident ';' { AbsHpl.FunOrRefDeclSF $3 $4 }
             | 'ref' Type Ident ';' { AbsHpl.FunOrRefDeclR $2 $3 }
ListFunOrRefDecl :: { [FunOrRefDecl] }
ListFunOrRefDecl : {- empty -} { [] }
                 | ListFunOrRefDecl FunOrRefDecl { flip (:) $1 $2 }
FunctionDef :: { FunctionDef }
FunctionDef : 'fun' Type Ident '(' ListFunctionArg ')' '=' ValueStatement ';' { AbsHpl.FunctionDefB $2 $3 $5 $8 }
            | 'sus' FunctionDef { AbsHpl.SusFunctionDef $2 }
FunctionArg :: { FunctionArg }
FunctionArg : PatternMatch { AbsHpl.FunctionArgB $1 }
ListFunctionArg :: { [FunctionArg] }
ListFunctionArg : {- empty -} { [] }
                | FunctionArg { (:[]) $1 }
                | FunctionArg ',' ListFunctionArg { (:) $1 $3 }
ValueStatement :: { ValueStatement }
ValueStatement : 'let' ListAssignment 'in' ValueStatement { AbsHpl.ValueStatementB (reverse $2) $4 }
               | 'force' 'let' ListAssignment 'in' ValueStatement { AbsHpl.ForceValueStatement (reverse $3) $5 }
               | 'if' ValueStatement 'then' ValueStatement 'else' ValueStatement { AbsHpl.IfValueStatement $2 $4 $6 }
               | ListValueStatementr { AbsHpl.LValueStatement $1 }
               | TupleValueStatementr { AbsHpl.TValueStatement $1 }
               | FunApplication { AbsHpl.AValueStatement $1 }
               | Integer { AbsHpl.IValueStatement $1 }
               | String { AbsHpl.LitStrValueStatement $1 }
               | '{' Ident '->' ValueStatement '}' { AbsHpl.FValueStatement $2 $4 }
               | ValueStatement ValueStatementExpr { AbsHpl.Expr $1 $2 }
ListValueStatement :: { [ValueStatement] }
ListValueStatement : {- empty -} { [] }
                   | ValueStatement { (:[]) $1 }
                   | ValueStatement ',' ListValueStatement { (:) $1 $3 }
RefDef :: { RefDef }
RefDef : 'ref' Type Ident '=' ValueStatement ';' { AbsHpl.RefDefB $2 $3 $5 }
Type :: { Type }
Type : Ident '(' ListType ')' { AbsHpl.TypeB $1 $3 }
     | '(' Type '->' Type ')' { AbsHpl.FunType $2 $4 }
     | '(' ListType ')' { AbsHpl.TType $2 }
ListType :: { [Type] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type ',' ListType { (:) $1 $3 }
AlgType :: { AlgType }
AlgType : 'data' Ident '(' ListTypeArg ')' '=' ListAlgTypeVal ';' { AbsHpl.AlgTypeB $2 $4 $7 }
TypeArg :: { TypeArg }
TypeArg : Ident { AbsHpl.TypeArgB $1 }
ListTypeArg :: { [TypeArg] }
ListTypeArg : {- empty -} { [] }
            | TypeArg { (:[]) $1 }
            | TypeArg ',' ListTypeArg { (:) $1 $3 }
AlgTypeVal :: { AlgTypeVal }
AlgTypeVal : Ident '(' Type ')' { AbsHpl.AlgTypeValB $1 $3 }
ListAlgTypeVal :: { [AlgTypeVal] }
ListAlgTypeVal : {- empty -} { [] }
               | AlgTypeVal { (:[]) $1 }
               | AlgTypeVal '|' ListAlgTypeVal { (:) $1 $3 }
PatternMatch :: { PatternMatch }
PatternMatch : Integer { AbsHpl.PatternMatchI $1 }
             | Ident { AbsHpl.PatternMatchB $1 }
             | '(' ListPatternMatch ')' { AbsHpl.TPatternMatch $2 }
             | PatternMatch '(' ListPatternMatch ')' { AbsHpl.CPatternMatch $1 $3 }
ListPatternMatch :: { [PatternMatch] }
ListPatternMatch : {- empty -} { [] }
                 | PatternMatch { (:[]) $1 }
                 | PatternMatch ',' ListPatternMatch { (:) $1 $3 }
Assignment :: { Assignment }
Assignment : Type '::' PatternMatch '=' ValueStatement ';' { AbsHpl.AssignmentB $1 $3 $5 }
           | RefDef { AbsHpl.RefAssignment $1 }
ListAssignment :: { [Assignment] }
ListAssignment : {- empty -} { [] }
               | ListAssignment Assignment { flip (:) $1 $2 }
FunApplication :: { FunApplication }
FunApplication : Ident '.' FunApplication { AbsHpl.SFunApplication $1 $3 }
               | Ident '(' ListFunctionArgAppl ')' { AbsHpl.FunApplicationB $1 $3 }
FunctionArgAppl :: { FunctionArgAppl }
FunctionArgAppl : ValueStatement { AbsHpl.FunctionArgApplB $1 }
ListFunctionArgAppl :: { [FunctionArgAppl] }
ListFunctionArgAppl : {- empty -} { [] }
                    | FunctionArgAppl { (:[]) $1 }
                    | FunctionArgAppl ',' ListFunctionArgAppl { (:) $1 $3 }
ListValueStatementr :: { ListValueStatementr }
ListValueStatementr : '[' ListValueStatement ']' { AbsHpl.ListValueStatementB $2 }
TupleValueStatementr :: { TupleValueStatementr }
TupleValueStatementr : '(' ListValueStatement ')' { AbsHpl.TupleValueStatementB $2 }
ValueStatementExpr :: { ValueStatementExpr }
ValueStatementExpr : '+' ValueStatement { AbsHpl.EAdd $2 }
                   | '-' ValueStatement { AbsHpl.ESub $2 }
                   | '%' ValueStatement { AbsHpl.EMod $2 }
                   | '*' ValueStatement { AbsHpl.EMul $2 }
                   | '/' ValueStatement { AbsHpl.EDiv $2 }
                   | '<' ValueStatement { AbsHpl.EL $2 }
                   | '<=' ValueStatement { AbsHpl.ELQ $2 }
                   | '>' ValueStatement { AbsHpl.EG $2 }
                   | '>=' ValueStatement { AbsHpl.EGQ $2 }
                   | '==' ValueStatement { AbsHpl.EEQ $2 }
                   | '!=' ValueStatement { AbsHpl.ENE $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

