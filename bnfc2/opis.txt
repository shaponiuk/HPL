Język Hpl, funkcyjno-obiektowy (lekko obiektowy), dostarczający też korutyny z globalnym dispatcherem i semaforami.
Jest też prawie całkiem leniwy (z wyjątkiem force - let - in).

W pliku na najwyższym poziomie znajdują się interfejsy, struktury oraz definicje typów algebraicznych.

Wykonania (uruchamiające pierwszą korutynę

Oczekuję ok. 30-35 pkt.

1. Typy Int, Bool, String, List, Tuple, inne algebraiczne, struktury i interfejsy struktur.

Int i String są dostępne jako literały, ale wszystkie i tak mają składnię typów algebraicznych.

2. Arytmetyka, arytmetyka porównania jako operatory, funkcje logiczne jako funkcje wbudowane

Tutaj mamy konflikty, jednak generowana przez parser struktura jest tak czy inaczej przerabiana przez interpreter

3. Wyrażenie warunkowe if - then - else.

4. Funkcje wieloargumentowe, rekurencja

5. Funkcje anonimowe, częściowa aplikacja, funkcje wyższego rzędu.

6. Obsługa błędów wykonania (zatrzymanie interpretera, komunikat o błędzie)

Np. dzielenie przez zero, albo deadlock (przy korutynach z globalnym dispatcherem jest to jak najbardziej możliwe do sprawdzenia)

7. Listy jako typ Algebraiczny dowolnego typu

data List a = Head a (List a) | EmptyList

Dostępny oczywiście pattern matching i wpisywanie literałów

8. Generyczne typy algebraiczne z dostępnym wielopoziomowym pattern matchingiem, rekurencyjne
Systemowe Maybe i Either też

9. Statyczne wiązanie identyfikatorów przy dowolnym poziomie zagnieżdżenia definicji

10. Statyczne typowanie z jawnym podawaniem typów

11. Dowolne zagnieżdżenie wzorców w pattern matchingu

12. Referencje, pozwalające zmieniać ich stan (w obrębie typu)

13. Struktury implementujące interfejsy, mogące mieć funkcje lub referencje, które są prywatne albo publiczne

14. let (przypisania z pattern matchingiem w obie strony) in

15. force let ---- in ----, wymusza, żeby to co jest między force let i in było wykonane po kolei i gorliwie, jak tylko zacznie się wykonanie funkcji

16. W pozostałych przypadkach wszystko jest wszystko leniwe

17. Korutyny z globalnym dispatcherem

Oznaczamy funkcję prefixem "sus", czyli ustawiamy ją na koniec kolejki wykonania, a nie wchodzimy w nią teraz
(przydatne przy użyciu (force let -- in))

Dodatkowo dostępne semafory do synchronizacji wykonań korutyny

Domyślnie program już się rozpoczyna od korutyny

Jest to na wzór kotlinx.coroutines w języku Kotlin

18. Wypisywanie na stdout, pobieranie z stdin

Funkcja print, typu (String -> ())
Funkcja get, typu (Int -> Maybe (String)), wczytująca podaną ilość znaków.
Funkcja getline, typu Maybe (String).
